var searchDocuments = {"references/eClassifiers/Publisher/index.html":{"action-uuid":"3d511216-3863-4ab2-a2a0-da31012fcbac","title":"Publisher","content":"Publisher passes inputs matching the condition to subscribers with matching input type and condition. Implementation attribute may be used for refining publishing functionality. E.g. it can be used as a name of a &ldquo;channel&rdquo;. Or it may be a composite configuration and also specify delivery multiplicity - one recipient, all recipients, anything in between."},"references/eClassifiers/Function/index.html":{"action-uuid":"a707b265-2ac9-4ebd-86e4-e1077d5dbc39","title":"Function","content":"Function takes input and produces output as a result."},"references/eClassifiers/Call/inheritance.html":{"path":"Call/Inheritance","action-uuid":"0c624ca5-b7aa-49c7-9588-c69da68d8593","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/SourceFunction/inheritance.html":{"path":"Source Function/Inheritance","action-uuid":"1d529d4b-159c-414a-b196-075fe789334d","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/Consumer/index.html":{"action-uuid":"e97dcf77-dee6-4064-b37a-2a7b6c989187","title":"Consumer","content":"Consumer processes inputs without producing outputs."},"references/eClassifiers/Supplier/references/eStructuralFeatures/output/index.html":{"path":"Supplier/Attributes/output","action-uuid":"ab8de688-0b19-4bfa-898e-244870a243a4","title":"output","content":"Output type"},"references/eClassifiers/SourceSupplier/inheritance.html":{"path":"Source Supplier/Inheritance","action-uuid":"2adaf4a1-3f9a-4191-a989-0b8c1610a5a3","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/SourceTransition/index.html":{"action-uuid":"35121daa-be09-4ae1-b669-1964317e50e9","title":"Source Transition","content":"Source transition executes its source to transform input to output."},"references/eClassifiers/FlowElement/references/eStructuralFeatures/implementation/index.html":{"path":"Flow Element/Attributes/implementation","action-uuid":"661c1be2-924d-4c61-a741-737d8e23b1d8","title":"implementation","content":"Meaning of implementation is generator/interpreter-specific. For example, for a Java generator it may be a fully qualified class name or a logical name which maps to a fully qualified class name. It may also be an expression returning the implementation, say constructor invocation."},"references/eClassifiers/SourceTransition/inheritance.html":{"path":"Source Transition/Inheritance","action-uuid":"9983c972-0b34-461b-8781-af0254c9890d","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/Call/references/eStructuralFeatures/targetOutput/index.html":{"path":"Call/Attributes/targetOutput","action-uuid":"d82f77df-f6a1-4008-96ae-f4fb9deb8085","title":"targetOutput","content":"Output type"},"references/eClassifiers/SupplierFlow/index.html":{"action-uuid":"5691c425-1b36-497c-ac99-54e11603eb2f","title":"Supplier Flow","content":"Supplier flow is a composite supplier."},"index.html":{"action-uuid":"f75a4a69-c95c-44ff-872d-3a3bda0cbeeb","title":"Function Flow","content":"Function flow model is intended to be used for modeling graphs of nodes passing data from one to another to achieve some goal. There are three base types of nodes: Supplier - provides data, e.g. listens on an HTTP port or reads a file. Consumer - received data and does something with it. E.g. writes to a file or sends an HTTP response. Function - produces output data from input data. Function is both a supplier and a consumer. In the above diagram: The supplier listens for HTTP requests, parses them and passes to the query database function The query database function uses the request data to retrieve information from a database and passes query results to the rendering function The rendering function generates response HTML The send response consumer sends the rendered response back There are many technology solutions doing similar things. However, many of them are built for specific target runtimes. The goal of this model to be runtime-agnostic, which allows modelers to focus on the &ldquo;business&rdquo; flow using terminology specific to their semantic domain. For example, &ldquo;book a flight&rdquo;. During modeling it should be irrelevant how a flight is booked - by making a REST call, sending a JMS message or adding a record to a database. Making such decisions during modeling might be premature and inefficient because it distracts from the primary goal - modeling a flow1. Even in the above rather low-level flow there are multiple variation points - there are different ways to listen for HTTP request, many different databases and ways to query them, &hellip; The following sections provide an overview of the model elements, explain how to map Drawio diagrams to this model, and provide some guidelines regarding generators. Summary Drawio mapping condition configuration errors implementation String Map input order output source target-input target-output Generation Interpretation Flow inheritance Usage scenario Summary As it was mentioned at the beginning, there are three base types of model elements - suppliers, consumers, and functions. A function is both a supplier and a consumer. Flow element is a base class for other model elements. Flow is a container of flow elements with several flavors - just a flow (command), supplier flow, function flow , and consumer flow. Suppliers, functions, and consumers communicate via transitions and calls. Error transitions are activated in case of errors. There are three flow element types which don&rsquo;t use transitions to communicate: Error handler - activated by errors which were not handled by error transitions. Publisher - publishes its inputs to subscribers. Subscriber - receives inputs from publishers. Start and End are flow input/output &ldquo;ports&rdquo; passing data from the flow to its elements. There is a number of source flavors of the above elements which allow to associates some type of source code with an element. The classifiers table lists all model elements alphabetically with short descriptions. The UML diagram shows model element relationships and attributes. There are also several types of graph representations including: Force graph Force graph with dependencies Drawio mapping Mapping of Drawio diagrams to Ecore models is explained in detail in the Beyond Diagrams book. This section documents diagram element properties specific for the function flow model. All properties below except order support -ref suffix to load them from an external resource resolved relative to the element&rsquo;s base-uri. For example, input property specifies input type, input-ref specifies a URI of a resource containing input type specification. The mapping logic just loads the below properties, what to do with them is up to the generation/execution logic. As such, the below sections are guidelines/suggestions which might be followed, extended, or ignored by the generator/interpreter providers. condition A condition for transitions, publishers, and subscribers. For generators it might be a boolean expression in the target language or a method body evaluating to boolean value. For a Java interpreter it might be a SpEL expression. configuration Element configuration. E.g. YAML configuration. errors A list of error types thrown by a given element. Similar to Java method throws clause. Errors value is loaded as YAML and if it is a list (array) then its elements are treated as error type specifications. Otherwise, the entire value it treated as a single error type specification. A type specification for errors, input, and output can be: String Logical name, e.g. Account Physical name, e.g. mypackage.Account Map (YAML, JSON, XML, &hellip;) Type specification (schema) Mapping of argument names to argument types - logical, physical, specifications Maven coordinates to add to dependencies or construct a classloader + type name implementation Flow element implementation specification to be used by a generator or an interpreter/executor. Below are a few suggestions for implementation format: String A logical or a physical name of implementation class/object which can be instantiated or looked up in some registry. For example in Java: http-listener - a logical name to be translated to an object by the generator. mypackage.HttpListener - service interface name. Service implementations are to be loaded by ServiceLoader mypackage.HttpListenerImpl - implementation class name to be instantiated. The string may also include Maven coordinates e.g. mypackage.HttpListenerImpl@my-group:my-artifact:my-version. Map A map in YAML, JSON, properties, XML, or other format may specify: Maven coordinates to add to dependencies in a generated pom.xml file or to create a classloader. Implementation class or service interface name. Configuration parameters as an alternative or addition to configuration input Input type for consumers, functions, and transitions. order Condition evaluation and type matching order for transitions. output Output type for suppliers, functions, and transitions. source Source code. Generators can copy it to the generated classes or use as a template (E.g. Apache FreeMarker or Mustache.java) to generate code. Interpreters may executed code. In Java interpreters may use scripting to evaluate source code. For example GraalVM ScriptEngine. target-input Input type for a call target. Defaults to the call input type if blank. target-output Output type for a call target. Defaults to the call output type if blank. Generation A generator for Java target may: Generate a single input parameter for consumers and functions Generate a list of parameters from maps Add context parameter to allow flow elements to set/get shared flow state and lookup services. E.g. Context or MutableContext. Add progress monitor parameter Reuse flow elements for multiple inputs or create a new instance of the top-level flow for every input, or use a pool of instances. Merge generated code with existing code preserving manual modifications. This would allow to have evolve the flow/implementations, flow configuration, and generated code in parallel and then merge the three lines of evolution. E.g. upgrade to a new flow version or change implementation or configuration for a flow element. Generation and merging can be done using the Java model. Generate suppliers, functions, and consumers as SupplierFactory, FunctionFactory, and ConsumerFactory respectively Generate multiple code flavors. For example, a simple synchronous flavor, which is easy to trace and debug, and reactive streams implementation for non-blocking asynchronous processing. Generate a compute (processors) graph. This can be done by an interpreter as well. Transitions might be generated as communication channels, e.g. Netty channels. It would allow to have multiple options to distribute generated code to processing nodes such as cloud VM&rsquo;s. This could possibly be combined with reactive code generation by leveraging Reactor Netty. Interpretation TODO - explain createFunction() and createProcessor() (from Graph) In Java an interpreter may use SpEL expressions for conditions, scripting to evaluate sources and Maven classloader to load implementations. It may pass progress monitor and context variables between flow elements. Flow inheritance Flow elements have unique id&rsquo;s. This allows to implement flow inheritance - overriding configuration of a base flow. Currently this functionality is not part of the model - it can be implemented by generators and interpreters. Usage scenario A flow is created in terms of the semantic domain. E.g. Enroll student to a class. Flows and elements are documented and documentation is published to be available to stakeholders. Flows may define actors and flow elements may define roles and actors in roles to assign responsibilities. Flows and flow elements may have a single or multiple implementations as well as multiple sets of configuration properties. This allows to have a multiple embodiments of the same flow for different use cases. Implementations may be bespoke or reusable. Diagram elements mapped to reusable implementations may be distributed as custom libraries2. Flows can form a hierarchy and flow element implementations can be flows or generated from flows. See Enterprise Model and the terminology chapter in the Beyond Diagrams book for more insights on value provided by diagramming/modeling. ↩ Create your own custom library ↩ HTTP Listener Query Database Send HTTP Response Render Results"},"references/eClassifiers/SourceFunction/index.html":{"action-uuid":"eb258694-f7d9-4b9c-8b1d-f256750e6970","title":"Source Function","content":"Source function executes its source code to create output from input."},"references/eClassifiers/Start/inheritance.html":{"path":"Start/Inheritance","action-uuid":"c50f503f-ae50-4c05-b81e-dc6bbf189d02","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/Call/references/eStructuralFeatures/targetInput/index.html":{"path":"Call/Attributes/targetInput","action-uuid":"9783b60f-535b-41d0-826a-1effd45678b7","title":"targetInput","content":"Output type"},"references/eClassifiers/ErrorHandler/inheritance.html":{"path":"Error Handler/Inheritance","action-uuid":"6e68f96e-8c71-47b8-8e3f-a77b1f945d2c","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/Function/inheritance.html":{"path":"Function/Inheritance","action-uuid":"fcf16f90-3de4-43d5-928c-576b300e6dde","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/ErrorTransition/index.html":{"action-uuid":"5285bf6a-24b9-444d-a0d5-5d26cc486807","title":"Error Transition","content":"Error transitions are activated by errors thrown by the source. If a flow element throws an error, outgoing error transitions are sorted by order, within the order they are sorted by error specificity if it is supported. Error transitions with conditions are matched before error transitions without conditions. The first transition to match error type and condition (if it is present) is activated."},"references/eClassifiers/SupplierFlow/inheritance.html":{"path":"Supplier Flow/Inheritance","action-uuid":"425d1160-9a29-432c-af2b-abac7e55cf23","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/Flow/index.html":{"action-uuid":"384cb891-c686-4466-9eb2-96b8dedd1ae2","title":"Flow","content":"Flow is a container for flow elements connected by transitions. It is a base class for other flow types - Supplier Flow, Consumer Flow, and Function Flow. Flow does not take inputs and does not produce outputs. As such it does not support Start and End - it is an element graph consisting of Suppliers, Functions, Consumers, and Error Handlers"},"references/eClassifiers/Consumer/references/eStructuralFeatures/input/index.html":{"path":"Consumer/Attributes/input","action-uuid":"db5ef519-58d0-4225-b8e6-cbd9c5b9f7e3","title":"input","content":"Output type"},"references/eClassifiers/Source/index.html":{"action-uuid":"e3f4693a-7cf4-4a18-ab9b-3147c8650aee","title":"Source","content":"Source is a base class for flow elements which execute source code. The meaning of source is implementation/generator specific. For a Java generation target it might be Java code and for a JavaScript generation target it might be JavaScript. However, depending on the implementation it might be some scripting language supported by Java scripting. It may also be a template which generates actual source code. E.g. Apache FreeMarker or Mustache.java."},"references/eClassifiers/SourceConsumer/inheritance.html":{"path":"Source Consumer/Inheritance","action-uuid":"241e7e40-ae1f-49b6-a82c-6839203495a4","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/Start/index.html":{"action-uuid":"6a8eb6f4-b0fd-4a43-9a1d-1a790a1d26b1","title":"Start","content":"Start passes containing Consumer/Function flow input to its outgoing transitions. A flow may have multiple starts. If there is more than one start then starts are sorted by order. Within the order value starts are sorted by output specificity if it is supported. Starts with conditions are matched before starts witout condition."},"references/eClassifiers/SourceErrorTransition/inheritance.html":{"path":"Source Error Transition/Inheritance","action-uuid":"4ae2016f-6e5c-4420-8b80-4ea044c7f885","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/Subscriber/index.html":{"action-uuid":"0e70552c-236a-4007-87b2-c14850105d1d","title":"Subscriber","content":"Subscribers receive inputs from publishers which match their input type and condition. Implementation attriute can be used for further refinement. For example, it can be used as a name of a &ldquo;channel&rdquo; or specify both channel name and priority (order)."},"references/eClassifiers/FunctionFlow/inheritance.html":{"path":"Function Flow/Inheritance","action-uuid":"633c7aeb-a33d-4a5c-8e5d-234b4640b344","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/FlowElement/references/eStructuralFeatures/errors/index.html":{"path":"Flow Element/Attributes/errors","action-uuid":"52472d4d-61c6-4500-b0ce-336a7d2b502e","title":"errors","content":"A list of errors which has different semantics for different element types: For Error Handler the error list defines errors which the handler handles. For Error Transition the error list defines errors activate the transition. For all other elements defines errors which the element throws. Java analogy: Error handler and transition - exception type in catch clause All other elements - exception types in throws clause"},"references/eClassifiers/Transition/inheritance.html":{"path":"Transition/Inheritance","action-uuid":"58993e45-efc8-493c-957c-7360914e10f2","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/End/inheritance.html":{"path":"End/Inheritance","action-uuid":"742e2585-2601-491d-be95-55a1791e3383","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/Supplier/inheritance.html":{"path":"Supplier/Inheritance","action-uuid":"eada3719-b3db-445a-a6cd-6da49d2b6d55","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/Subscriber/inheritance.html":{"path":"Subscriber/Inheritance","action-uuid":"2e67360a-a1ae-46d3-8657-097ede7b242f","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/End/index.html":{"action-uuid":"41b66e75-15ef-4137-aef1-2e8450f75bf4","title":"End","content":"End input is used as an output of the containing flow."},"references/eClassifiers/Call/index.html":{"action-uuid":"c409b39d-1b3b-484f-99c1-10d5d4ded2ea","title":"Call","content":"Calls a function node and returns result to the caller. It may be thought of as two transitions - to the calling function and back to the caller. Condition and order attributes can be used for aggregating multiple call in one as in if - else if - else chain."},"references/eClassifiers/ConsumerFlow/index.html":{"action-uuid":"d4e16d8b-bab1-4487-a67f-9555cf6a6d03","title":"Consumer Flow","content":"Consumer flow passes its inputs to a matching Start."},"references/eClassifiers/FlowElement/references/eStructuralFeatures/configuration/index.html":{"path":"Flow Element/Attributes/configuration","action-uuid":"5cbdf122-6851-40a5-8d31-64b0242524e3","title":"configuration","content":"Flow element configuration."},"references/eClassifiers/Consumer/inheritance.html":{"path":"Consumer/Inheritance","action-uuid":"fb75dfb0-a79c-419b-ba01-a9a2c7973ab2","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/Transition/index.html":{"action-uuid":"6cee691f-660b-40f5-ad98-fe28c5ee4c87","title":"Transition","content":"Transisitions are functions which take source output as their input. Transition output is passes to its target as input. Only one transition is activated by the source output. Transitions are evauated for activation in the the order defined by the order property. Transitions within the same order are ordered by type specificity, if it is supported. Within the same type (or absense of thereof) transitions with conditions are evaluated before transition(s) without conditions."},"references/eClassifiers/Publisher/inheritance.html":{"path":"Publisher/Inheritance","action-uuid":"75344335-b582-41e8-a694-3455a0036a43","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/FlowElement/index.html":{"action-uuid":"dc16ed94-5319-46a3-a08d-30db53035e37","title":"Flow Element","content":"Base class for flow elements. Defines errors and implementation attributes. errors has different semantics depending on a sub-class and is not applicable to some sub-classes."},"references/eClassifiers/Transition/references/eStructuralFeatures/output/index.html":{"path":"Transition/Attributes/output","action-uuid":"fc53f959-532f-48e0-9781-f655b4955821","title":"output","content":"Output type"},"references/eClassifiers/SourceCall/inheritance.html":{"path":"Source Call/Inheritance","action-uuid":"894073b1-2cc1-4cdc-a6c2-2c0eb70ce8e4","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/SourceErrorTransition/index.html":{"action-uuid":"109b12f0-acd0-469d-a0a8-2240780fd7e4","title":"Source Error Transition","content":"Source error transition executes its source code to transform the input error to transition output."},"references/eClassifiers/SourceSupplier/index.html":{"action-uuid":"e5f36fdf-4e27-4b36-93df-90320e4d0af8","title":"Source Supplier","content":"Source supplier executes its source code to supply output objects. For example, the source code may create an HTTP listener to supply HTTP request/response pairs (exchanges)."},"references/eClassifiers/FlowElement/inheritance.html":{"path":"Flow Element/Inheritance","action-uuid":"2243393a-ceed-4715-8f28-76b31db71d73","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/SourceCall/index.html":{"action-uuid":"5a108312-300c-40a5-bd38-2d1a388463a8","title":"Source Call","content":"Source call executes its source to transform input to target input and then target output to output."},"references/eClassifiers/Transition/references/eStructuralFeatures/input/index.html":{"path":"Transition/Attributes/input","action-uuid":"bc520307-746d-425e-b126-7931cf482769","title":"input","content":"Output type"},"glossary.html":{"action-uuid":"8aa4b239-986e-43d0-8951-cc93d420220b","title":"Glossary","content":"Clear Identifier(s) Hide UUID {{data.value.name}} {{data.value[0].value}} {{item.value}}"},"references/eClassifiers/FunctionFlow/index.html":{"action-uuid":"f0b18b62-1ad5-4363-ae6f-704e1616423d","title":"Function Flow","content":"Function flow takes inputs and passes them to a matching Start element. It then collects output from its End element and uses it as flow output."},"references/eClassifiers/Start/references/eStructuralFeatures/output/index.html":{"path":"Start/Attributes/output","action-uuid":"31ef19fd-8ec6-48a8-83fc-0e884d3b00e7","title":"output","content":"Output type"},"references/eClassifiers/SourceConsumer/index.html":{"action-uuid":"3a23b6ca-3889-4a9a-9af0-6e83b6772115","title":"Source Consumer","content":"Source consumer executes source code to process its inputs."},"references/eClassifiers/Source/inheritance.html":{"path":"Source/Inheritance","action-uuid":"db49faf0-40a9-4736-9a5f-e4c93f29b378","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/ConsumerFlow/inheritance.html":{"path":"Consumer Flow/Inheritance","action-uuid":"d4a90723-4f32-47ce-a755-e82762d5c839","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/Flow/inheritance.html":{"path":"Flow/Inheritance","action-uuid":"2125929d-7d26-4494-a379-ec533d0fdd41","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/ErrorHandler/index.html":{"action-uuid":"58bd98ce-8bd5-488e-9902-b5a5ada91149","title":"Error Handler","content":"If a flow element throws an error and there are no matching error transitions, then the error is handled by an error handler with matching errors. Error handlers are sorted in the order of error specificity, if it is supported. Otherwise they are matched with the error in the order they are defined in the model."},"references/eClassifiers/SourceErrorHandler/inheritance.html":{"path":"Source Error Handler/Inheritance","action-uuid":"84efe10a-c2c2-4f63-a2ed-6a9b1bf2b79b","title":"Inheritance","content":"Supertypes "},"references/eClassifiers/SourceErrorHandler/index.html":{"action-uuid":"53b82fcc-8286-41cd-94c7-48661b215ccb","title":"Source Error Handler","content":"Source error handler executes source code to handle errors not handled by error transitions."},"references/eClassifiers/ErrorTransition/inheritance.html":{"path":"Error Transition/Inheritance","action-uuid":"8dcd61bf-0a66-41e6-b892-0fd99e7e71c6","title":"Inheritance","content":"Supertypes Subtypes  "},"references/eClassifiers/Supplier/index.html":{"action-uuid":"d8adc912-ce50-4fe0-8ab0-207ad768e09e","title":"Supplier","content":"Suppliers are sources of objects of output type which are passed via transitions to functions and consumers. Examples: HTTP listener File reader"}}